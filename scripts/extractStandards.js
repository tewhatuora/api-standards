const fs = require("fs");
const path = require("path");
const cheerio = require("cheerio");

const sourceDir = "./build";
const outputFilePath = "./build/assets/api-standards.json";

// Set to store Standards IDs and content to check uniqueness
const standardsIds = new Set();
const standardsContent = {};
const duplicates = new Set();
const invalid = new Set();

// Regular expression to match the desired format (e.g., HNZAS_MUST_NOT_X_NOTATION_HEADERS)
const idFormatRegex = /^HNZAS_(MUST|MUST_NOT|SHOULD|SHOULD_NOT|MAY)_[\w_]+$/;

const standardTypes = "MUST|MUST_NOT|SHOULD|SHOULD_NOT|MAY".replace(/_/g, ' ').split('|')

// extracts the API Standards from the HTML files, generated by the src/components/ApiStandard.jsx components
function extractDataFromHTML(filePath, htmlContent) {
  const $ = cheerio.load(htmlContent);
  const elementsWithDataStandardType = [];

  $("[data-standard-type]").each((index, element) => {
    const $element = $(element);

    const standardType = $element.attr("data-standard-type");
    const content = $element.attr("data-extended-text");
    const id = $element.attr("id");

    // Check for duplicate IDs
    if (standardsIds.has(id)) {
      if (standardsContent[id] !== content) {
        console.log(standardsContent[id], content);
        // An unintentional dupe has been written with different content for the same rule
        duplicates.add(id);
      }
      else {
        // This is just the second time this rule's been used; skip it from the checklist
        return;
      }
    }

    // Check the format against the regex
    if (!idFormatRegex.test(id)) {
      invalid.add(id);
      return;
    }

    // Check that `type` is valid and matches ID
    if (!standardTypes.includes(standardType) || !id.startsWith(`HNZAS_${standardType.replace(' ', '_')}`)) {
      console.log(standardTypes.includes(standardType), id.startsWith(`HNZAS_${standardType.replace(' ', '_')}`), standardType, id);
      invalid.add(id);
      return;
    }

    standardsIds.add(id);
    standardsContent[id] = content;
    elementsWithDataStandardType.push({ standardType, content, id, filePath });
  });

  return elementsWithDataStandardType;
}

function processHTMLFile(filePath) {
  const htmlContent = fs.readFileSync(filePath, "utf-8");
  return extractDataFromHTML(filePath, htmlContent);
}

// iterates recursively over the build directory and processes all HTML files
function processDirectory(directoryPath) {
  const fileNames = fs.readdirSync(directoryPath);

  const data = fileNames.flatMap((fileName) => {
    const filePath = path.join(directoryPath, fileName);
    if (fs.statSync(filePath).isDirectory()) {
      return processDirectory(filePath);
    } else if (fileName.endsWith(".html")) {
      return processHTMLFile(filePath);
    }
    return [];
  });

  return data;
}

function main() {
  const data = processDirectory(sourceDir);

  // After data is processed, check for duplicates or invalid standards

  if (duplicates.size > 0) { 
    console.log(`Duplicate Standards ID found: ${[...duplicates].join("\n")}`);
  }
  if (invalid.size > 0) {
    console.log(`Invalid Standards ID found: ${[...invalid].join("\n")}`);
  }
  if (duplicates.size > 0 || invalid.size > 0) {
    throw new Error("Duplicate or invalid Standards ID found. Please fix the issues before proceeding.");
  }

  const groupedData = {};

  data.forEach(({ standardType, content, id, filePath }) => {
    if (!groupedData[standardType]) {
      groupedData[standardType] = [];
    }
    // generates a link to the standard in the generated html (including fragment)
    const link =
      filePath.replace("build", "").replace("/index.html", "") + `#${id}`;
    groupedData[standardType].push({ standardType, content, id, link });
  });

  const jsonData = JSON.stringify(groupedData, null, 2);
  fs.writeFileSync(outputFilePath, jsonData);

  console.log(`Standards extracted and grouped. Written to ${outputFilePath}`);
}

main();
